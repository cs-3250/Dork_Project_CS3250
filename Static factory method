A class can provide a public static factory
method, which is simply a static method that returns an instance of the class.
Here’s a simple example from Boolean (the boxed primitive class for
boolean). This method translates a boolean primitive value into a
Boolean object reference:
public static Boolean valueOf(boolean b) {
return b ? Boolean.TRUE : Boolean.FALSE;
}

a static factory method is not the same as the Factory Method
pattern from Design Patterns.  The static factory method
described in this item has no direct equivalent in Design Patterns

One advantage of static factory methods is that, unlike constructors,
they have names. If the parameters to a constructor do not, in and of
themselves, describe the object being returned, a static factory with a wellchosen
name is easier to use and the resulting client code easier to read. For
example, the constructor BigInteger(int, int, Random), which
returns a BigInteger that is probably prime, would have been better
expressed as a static factory method named
BigInteger.probablePrime. (This method was added in Java 4.)

A class can have only a single constructor with a given signature.
Programmers have been known to get around this restriction by providing two constructors 
whose parameter lists differ only in the order of their parameter types. This is a 
really bad idea. The user of such an API will never be able to remember which constructor 
is which and will end up calling the wrong one by mistake. People reading code that uses 
these constructors will not know what the code does without referring to the class documentation.

A second advantage of static factory methods is that, unlike
constructors, they are not required to create a new object each time
they’re invoked.

The
Boolean.valueOf(boolean) method illustrates this technique: it never
creates an object. This technique is similar to the Flyweight pattern

A third advantage of static factory methods is that, unlike
constructors, they can return an object of any subtype of their return
type.
One application of this flexibility is that an API can return objects without
making their classes public. Hiding implementation classes in this fashion
leads to a very compact API. This technique lends itself to interface-based
frameworks (Item 20), where interfaces provide natural return types for static factory methods.

A fourth advantage of static factories is that the class of the returned
object can vary from call to call as a function of the input parameters.
Any subtype of the declared return type is permissible. The class of the
returned object can also vary from release to release.
The EnumSet class (Item 36) has no public constructors, only static
factories. In the OpenJDK implementation, they return an instance of one of
two subclasses, depending on the size of the underlying enum type: if it has
sixty-four or fewer elements, as most enum types do, the static factories
return a RegularEnumSet instance, which is backed by a single long; if
the enum type has sixty-five or more elements, the factories return a
JumboEnumSet instance, backed by a long array.
The existence of these two implementation classes is invisible to clients. If
RegularEnumSet ceased to offer performance advantages for small enum
types, it could be eliminated from a future release with no ill effects.
Similarly, a future release could add a third or fourth implementation of
EnumSet if it proved beneficial for performance. Clients neither know nor
care about the class of the object they get back from the factory; they care
only that it is some subclass of EnumSet.

A fifth advantage of static factories is that the class of the returned
object need not exist when the class containing the method is written.
Such flexible static factory methods form the basis of service provider
frameworks, like the Java Database Connectivity API (JDBC). A service
provider framework is a system in which providers implement a service, and
the system makes the implementations available to clients, decoupling the
clients from the implementations.

a provider registration
API, which providers use to register implementations; and a service access
API, which clients use to obtain instances of the service. The service access
API may allow clients to specify criteria for choosing an implementation. In
the absence of such criteria, the API returns an instance of a default
implementation, or allows the client to cycle through all available
implementations. The service access API is the flexible static factory that
forms the basis of the service provider framework.

The main limitation of providing only static factory methods is that
classes without public or protected constructors cannot be subclassed.

second shortcoming of static factory methods is that they are hard
for programmers to find.
